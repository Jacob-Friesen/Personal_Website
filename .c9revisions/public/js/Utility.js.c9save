{"ts":1347300529541,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"// modified from http://javascript.crockford.com/prototypal.html\nif (typeof Object.nu !== 'function') {\n    Object.nu = function (o) {\n        function F() {};\n        F.prototype = o;\n        return new F();\n    };\n} else { alert(\"Object.nu is already defined\"); }\n\nvar utility = {\n    \n    init: function(){\n        this.change_text.init();\n        \n        return this;\n    },\n    \n    // Modifies top menu icon spacing values to reflect window size change. Will not work when virtual keyboard is used but\n    // that isn't used in this site.\n    orientation_compensation: function(){\n        if (Math.abs(window.orientation) != 90)  \n            $('#home_link').css('margin-left', 0);\n        else\n            $('#home_link').css('margin-left', '33px');\n    },\n    \n    // (psuedo-function)\n    // Cycles through each element retrieved by collapse_with attaching the specified action to an event. When this event is\n    // triggered the id of the current object is found and put in behind the collapse_to selector. If delay is sent the function\n    // is only initialized for later use.\n    attach_show_events: function(params){\n        var attacher = {\n            // Initializes all arguments then starts execution, finally returning its parent object.\n            init: function(delay){\n                this.triggers = params[\"triggers\"];\n                this.event = params[\"event\"];\n                this.collapsers = params[\"collapsers\"];\n                this.on_hide = params[\"on_hide\"];\n                this.on_show = params[\"on_show\"];\n                this.chk_attr = \"name\";\n                if (params[\"chk_attr\"]) this.chk_attr = params[\"chk_attr\"];\n                \n                if (!delay) this.attach_events();\n                return this;\n            },\n            \n            // Attach each trigger to its corresponding collapser if it has a corresponding collapser. Keeps on trying\n            // to find a collapser by looking ahead.\n            attach_events: function(){\n                this.order_matchers_by_name();\n                \n                // length must be the same so no point in checking triggers length\n                for(var t = 0, c = 0; t < this.triggers.length && c < this.triggers.length; c++){\n                    if($(this.triggers[t]).attr(this.chk_attr) == $(this.collapsers[c]).attr(this.chk_attr)) {\n                        this.triggers[t].collapser = this.collapsers[c];\n                        $(this.triggers[t])[this.event]($.proxy(this.on_event, this));\n                        t += 1;\n                    }\n                }\n            },\n            \n            // call the on_hide/show events when appropriate passes in the trigger and event that is to be hidden.\n            on_event: function(element){\n                var trigger = element.currentTarget\n                if ($(trigger.collapser).css('display') == 'none')\n                    this.on_show(trigger, trigger.collapser);\n                else\n                    this.on_hide(trigger, trigger.collapser);\n            },\n            \n            // does an on_show/on_hide event with the current element\n            open: function(index){\n                this.do_event(\"on_show\", index);\n                return this\n            },\n            close: function(index){\n                this.do_event(\"on_hide\", index);\n                return this;\n            },\n            do_event: function(event, index){\n                if (index == \"all\") {\n                    for(var t = 0;t < this.triggers.length; t++)\n                        this[event](this.triggers[t], this.triggers[t].collapser);\n                }\n                else\n                    this[event](this.triggers[index], this.triggers[index].collapser);\n            },\n            \n            // orders set of collapsers and orderers by id\n            order_matchers_by_name: function(){\n                if (!this.triggers || !this.triggers.sort) return false;\n                if (!this.collapsers || !this.collapsers.sort) return false;\n                \n                // I assume they are the same length for this algorithm to work\n                if (this.triggers.length != this.collapsers.length) throw('triggers must be the same length as collapsers');\n                \n                var parent = this;\n                var sorter = function(a, b){\n                    if ($(a).attr(parent.chk_attr) > $(b).attr(parent.chk_attr)) return 1;\n                    if ($(a).attr(parent.chk_attr) < $(b).attr(parent.chk_attr)) return -1;\n                    return 0;\n                }\n                \n                this.triggers.sort(sorter);\n                this.collapsers.sort(sorter);\n                \n                return true;\n            },\n            \n            // Gets the item to collapse by getting the id of the collapser and combining it\n            // with the collapse_to selector. \n            get_collapsee :function(collapser){\n                var id = collapser.id.split('_').pop();\n                return $('#'+this.collapse_to+id);\n            }\n        }\n        \n        return Object.nu(attacher.init(params[\"delay\"]));\n    },\n    \n    // handles updating of layouts\n    update_layout: {\n        \n        changes: {\n            //'#menu_center': {\n            //    0.75: ['width', '95.75%'],\n            //    1: ['width', '95.75%'],\n            //    1.25: ['width', '100%']\n            //}\n        },\n        \n        // Updates the selector (if it can be found) with the appropriate values\n        // for the current multiple.\n        update: function(multiple){\n            for (selector in this.changes){\n                var element = $(selector);\n                if (element[0])\n                    element.css(this.changes[selector][multiple][0], this.changes[selector][multiple][1]);\n            }\n        }\n    },\n    \n    // Uses the css set font sizes as a baseline to scale all fonts\n    change_text: {\n        current_scale: 1,\n        \n        // Each of these gets a original_font_size set. Also very inefficient.\n        TO_CHANGE: [\n            [document.body, -1],//selector, default font size\n            ['h1', -1],\n            ['h4', -1]\n        ],\n        \n        to: {\n            small: function(){ utility.change_text.change_size_by(0.75); },\n            normal: function(){ utility.change_text.change_size_by(1); },\n            large: function(){ utility.change_text.change_size_by(1.25); }\n        },\n        \n        // Gets all the above elements current font-size and stores that as the default.\n        init: function(){\n            for(var i = 0; i < this.TO_CHANGE.length; i++){\n                var element = $(this.TO_CHANGE[i][0]).first();\n                \n                if (element[0])\n                    this.TO_CHANGE[i][1] = Number(element.css('font-size').replace('px',''));\n            }\n        },\n        \n        // Multiplies all elements original font size by multiple. The updates the page layout.\n        change_size_by: function(multiple){\n            //record size so it can be used outside of this object\n            this.current_scale = multiple;\n            \n            for(var i = 0; i < this.TO_CHANGE.length; i++){\n                var element = $(this.TO_CHANGE[i][0]);\n                var def_size = this.TO_CHANGE[i][1];\n                \n                // Loop through all items if selector retrieves a list\n                if (element[0] && element.length > 1){\n                    for(var j = 0; j < element.length; j++)\n                        $(element[j]).css('font-size', def_size * multiple);\n                }\n                else if (element[0])\n                    element.css('font-size', def_size * multiple);\n            }\n            \n            utility.update_layout.update(multiple);\n        }\n    }\n}.init();"]],"start1":0,"start2":0,"length1":0,"length2":7820}]],"length":7820}
